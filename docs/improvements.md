# Архитектурные улучшения NormaGPT

## Обзор проблемы

По результатам анализа логов выполнения агента NormaGPT была выявлена **центральная проблема зацикливания в состоянии REPLAN**. Система успешно находила нормативные данные, но не могла перейти к заключительному шагу — расчету. "Судья" справедливо решал, что цель не достигнута, и запускал перепланировку. Однако "Планировщик" снова и снова создавал план по *поиску* информации, не зная, как создать план для ее *использования*.

## Внесенные улучшения

### 1. Внедрение Pydantic для валидации вывода LLM

**Проблема:** Система "слепо" доверяла, что LLM вернет валидный YAML. Если формат нарушен или ключ отсутствует, это приводило к ошибкам типа `'NoneType' object is not subscriptable`.

**Решение:** 
- Создан файл `utils/schemas.py` с полными Pydantic схемами для всех агентов
- Добавлена валидация в `utils/parse_yaml.py` с использованием схем
- Созданы специализированные функции парсинга: `parse_planner_response()`, `parse_analyzer_response()`, `parse_judge_response()`, `parse_finalizer_response()`

**Файлы:**
- `utils/schemas.py` - Pydantic схемы с валидацией
- `utils/parse_yaml.py` - Обновленный парсер с Pydantic интеграцией

### 2. Вынесение промптов во внешние файлы

**Проблема:** Хранение громоздких промптов в словаре `YAML_PROMPTS` внутри Python-кода затрудняло их чтение, редактирование и версионирование.

**Решение:**
- Создана директория `prompts/` для хранения промптов в отдельных файлах
- Создан класс `PromptLoader` в `utils/prompt_loader.py` для загрузки промптов
- Промпты вынесены в файлы:
  - `prompts/planner.txt` - улучшенный промпт планировщика
  - `prompts/analyzer.txt` - улучшенный промпт анализатора  
  - `prompts/judge.txt` - улучшенный промпт судьи
  - `prompts/finalizer.txt` - промпт финализатора

**Файлы:**
- `utils/prompt_loader.py` - Загрузчик промптов из файлов
- `prompts/` - Директория с промптами

### 3. Ключевые улучшения промптов

#### Планировщик (`prompts/planner.txt`)
- **Добавлено явное описание инструмента `calculate`** с примерами использования
- **Пример сложного плана** с этапами поиска + расчета
- Четкое объяснение синтаксиса ссылок на результаты предыдущих шагов

#### Анализатор (`prompts/analyzer.txt`)  
- **Обязательное поле `structured_output`** для машиночитаемых данных
- Четкие требования к структуре данных для использования в `calculate`
- Валидация полей `entity`, `value`, `variable_name`, `source_reference`

#### Судья (`prompts/judge.txt`)
- **Новая стратегия `FORM_CALCULATION_STEP`** для создания шагов расчета
- Четкие правила принятия решения `FINALIZE` vs `REPLAN`
- Инструкции по обновлению контекста с найденными данными

### 4. Инструмент расчетов

**Проблема:** Отсутствовал надежный инструмент для выполнения математических расчетов.

**Решение:**
- Создан новый файл `utils/calculate.py` с функцией `calculate()`
- Поддержка переменных, математических функций и констант
- Валидация входных данных с Pydantic схемами
- Детальные шаги вычисления для отладки
- Обработка ссылок на результаты предыдущих шагов

**Файлы:**
- `utils/calculate.py` - Инструмент для математических расчетов

### 5. Обновление узлов системы

**Изменения в `nodes.py`:**
- Обновлены импорты для использования новых утилит
- `ExecutorNode` теперь использует `get_analyzer_prompt()`
- Добавлена поддержка инструмента `calculate` в `ExecutorNode`
- Улучшена обработка результатов расчетов

## Результат улучшений

### Устранение зацикливания
1. **Планировщик** теперь знает о существовании инструмента `calculate` и может создавать шаги расчета
2. **Анализатор** возвращает структурированные данные в поле `structured_output`
3. **Судья** может явно направить планировщика на создание шагов расчета через стратегию `FORM_CALCULATION_STEP`

### Повышение надежности
1. **Pydantic валидация** предотвращает падение системы из-за некорректного вывода LLM
2. **Машиночитаемый `structured_output`** обеспечивает надежный поток данных между компонентами
3. **Инструмент `calculate`** выполняет безопасные математические вычисления

### Улучшение поддерживаемости  
1. **Промпты в отдельных файлах** упрощают их редактирование и версионирование
2. **Четкое разделение кода и конфигурации** повышает читаемость
3. **Pydantic схемы** документируют структуру данных

## Использование

### Тестирование компонентов

```bash
# Тест загрузчика промптов
python3 utils/prompt_loader.py

# Тест инструмента расчетов  
PYTHONPATH=. python3 utils/calculate.py

# Тест парсинга с Pydantic
PYTHONPATH=. python3 utils/parse_yaml.py
```

### Запуск системы

```bash
python3 main.py
```

## Следующие шаги

1. **Полная интеграция ссылок на шаги** - Реализовать логику извлечения значений из `{step_X.structured_output.value}`
2. **Расширение валидации** - Добавить больше проверок в Pydantic схемы
3. **Мониторинг производительности** - Добавить метрики успешности выполнения планов
4. **Обучение на примерах** - Пополнить промпты большим количеством примеров успешных планов 